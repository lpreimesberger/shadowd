package lib

import (
	"context"
	"crypto/sha256"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"time"

	"golang.org/x/crypto/blake2b"

	abcitypes "github.com/cometbft/cometbft/abci/types"
	"github.com/cometbft/cometbft/config"
	tmlog "github.com/cometbft/cometbft/libs/log"
	"github.com/cometbft/cometbft/mempool"
	"github.com/cometbft/cometbft/node"
	"github.com/cometbft/cometbft/p2p"
	"github.com/cometbft/cometbft/privval"
	tmproto "github.com/cometbft/cometbft/proto/tendermint/types"
	"github.com/cometbft/cometbft/proxy"
)

// TendermintConfig holds configuration for the Tendermint node
type TendermintConfig struct {
	HomeDir           string   // Home directory for Tendermint files
	GenesisDoc        string   // Genesis document JSON
	Seeds             []string // Seed nodes
	P2PListenAddr     string   // P2P listen address
	RPCListenAddr     string   // RPC listen address
	LogLevel          string   // Log level
	CreateEmptyBlocks bool     // Whether to create empty blocks
}

// TendermintNode wraps a CometBFT node
type TendermintNode struct {
	node   *node.Node
	config *TendermintConfig
	logger tmlog.Logger
	ctx    context.Context
	cancel context.CancelFunc
	app    *ShadowyApp
}

// DefaultTendermintConfig returns sensible defaults for Tendermint configuration
func DefaultTendermintConfig(blockchainDir string, seeds []string, quiet bool) *TendermintConfig {
	logLevel := "info"
	if quiet {
		// Tendermint has unique logging modules that can be very noisy
		// Common noisy modules: p2p, consensus, state, mempool, blockchain
		logLevel = "error"
	}

	return &TendermintConfig{
		HomeDir:           blockchainDir,
		GenesisDoc:        GetEmbeddedTestnetGenesis(),
		Seeds:             seeds,
		P2PListenAddr:     "tcp://0.0.0.0:26666",
		RPCListenAddr:     "tcp://127.0.0.1:26667",
		LogLevel:          logLevel,
		CreateEmptyBlocks: true, // Enable block production for mining
	}
}

// NewTendermintNode creates a new Tendermint node instance
func NewTendermintNode(tmConfig *TendermintConfig) (*TendermintNode, error) {
	ctx, cancel := context.WithCancel(context.Background())

	// Create logger
	var logger tmlog.Logger
	if tmConfig.LogLevel == "error" {
		// Redirect Tendermint logs to discard for quiet mode
		logger = tmlog.NewTMLogger(tmlog.NewSyncWriter(io.Discard))
	} else {
		logger = tmlog.NewTMLogger(tmlog.NewSyncWriter(os.Stdout))
	}

	// Apply log level filtering
	levelOption, err := tmlog.AllowLevel(tmConfig.LogLevel)
	if err != nil {
		cancel()
		return nil, fmt.Errorf("failed to parse log level: %w", err)
	}
	logger = tmlog.NewFilter(logger, levelOption)

	// Initialize Tendermint configuration
	cfg, err := initializeTendermintConfig(tmConfig)
	if err != nil {
		cancel()
		return nil, fmt.Errorf("failed to initialize Tendermint config: %w", err)
	}

	// Create application (we'll use a default address for now, will be updated later)
	var defaultAddress Address
	app := NewShadowyApp(defaultAddress)

	// Check if we have a validator key (determines if we're a validator or full node)
	validatorKeyExists := false
	if _, err := os.Stat(cfg.PrivValidatorKeyFile()); err == nil {
		validatorKeyExists = true
	}

	// Load validator - always load even for non-validators to avoid nil pointer
	// Tendermint will create the files if they don't exist, but won't use them
	// if this node isn't in the genesis validators list
	pv := privval.LoadOrGenFilePV(cfg.PrivValidatorKeyFile(), cfg.PrivValidatorStateFile())

	// Set validator flag on app
	app.isValidator = validatorKeyExists

	// Load node key from persistent location (outside blockchain directory)
	persistentNodeKeyFile := "node_key.json"
	nodeKey, err := p2p.LoadOrGenNodeKey(persistentNodeKeyFile)
	if err != nil {
		cancel()
		return nil, fmt.Errorf("failed to load node key: %w", err)
	}

	// Copy the persistent node key to the blockchain config directory for Tendermint
	blockchainNodeKeyFile := cfg.NodeKeyFile()
	if err := copyNodeKey(persistentNodeKeyFile, blockchainNodeKeyFile); err != nil {
		cancel()
		return nil, fmt.Errorf("failed to copy node key: %w", err)
	}

	// Create database provider (use in-memory for now to avoid file issues)
	dbProvider := func(ctx *node.DBContext) (db.DB, error) {
		return db.NewMemDB(), nil
	}

	// Create Tendermint node
	tmNode, err := node.NewNode(
		cfg,
		pv,
		nodeKey,
		proxy.NewLocalClientCreator(app),
		node.DefaultGenesisDocProviderFunc(cfg),
		dbProvider,
		node.DefaultMetricsProvider(cfg.Instrumentation),
		logger,
	)
	if err != nil {
		cancel()
		return nil, fmt.Errorf("failed to create Tendermint node: %w", err)
	}

	return &TendermintNode{
		node:   tmNode,
		config: tmConfig,
		logger: logger,
		ctx:    ctx,
		cancel: cancel,
		app:    app,
	}, nil
}

// Start starts the Tendermint node
func (tn *TendermintNode) Start() error {
	if err := tn.node.Start(); err != nil {
		return fmt.Errorf("failed to start Tendermint node: %w", err)
	}

	// Wait a moment for node to initialize
	time.Sleep(100 * time.Millisecond)

	return nil
}

// Stop stops the Tendermint node
func (tn *TendermintNode) Stop() error {
	tn.cancel()
	if err := tn.node.Stop(); err != nil {
		return fmt.Errorf("failed to stop Tendermint node: %w", err)
	}
	tn.node.Wait()
	return nil
}

// BroadcastTransaction submits a transaction to the mempool via RPC
func (tn *TendermintNode) BroadcastTransaction(txBytes []byte) error {
	if tn.node == nil {
		return fmt.Errorf("Tendermint node not started")
	}

	// Use the node's mempool to add the transaction
	// This will trigger CheckTx for validation
	// Create empty TxInfo for the mempool
	txInfo := mempool.TxInfo{}
	if err := tn.node.Mempool().CheckTx(txBytes, nil, txInfo); err != nil {
		return fmt.Errorf("mempool rejected transaction: %w", err)
	}

	return nil
}

// GetMempoolTransactions returns all pending transactions from the mempool
func (tn *TendermintNode) GetMempoolTransactions() ([]*Transaction, error) {
	if tn.node == nil {
		return nil, fmt.Errorf("Tendermint node not started")
	}

	// Get all transactions from mempool (-1 means no limit)
	txs := tn.node.Mempool().ReapMaxTxs(-1)

	var transactions []*Transaction
	for _, txBytes := range txs {
		var tx Transaction
		if err := json.Unmarshal(txBytes, &tx); err != nil {
			// Skip transactions that can't be unmarshaled (might be non-JSON txs)
			continue
		}
		transactions = append(transactions, &tx)
	}

	return transactions, nil
}

// SetNodeAddress sets the node wallet address for coinbase rewards
func (tn *TendermintNode) SetNodeAddress(address Address) {
	if tn.app != nil {
		tn.app.nodeAddress = address
	}
}

// SetNodePrivateKey sets the node wallet private key for mining
func (tn *TendermintNode) SetNodePrivateKey(privateKey []byte) {
	if tn.app != nil {
		tn.app.nodePrivateKey = privateKey
	}
}

// GetNodeID returns the Tendermint node ID
func (tn *TendermintNode) GetNodeID() (string, error) {
	// Use the same persistent file location
	nodeKey, err := p2p.LoadOrGenNodeKey("node_key.json")
	if err != nil {
		return "", fmt.Errorf("failed to load node key: %w", err)
	}
	return string(nodeKey.ID()), nil
}

// SaveNodeIDToFile saves the node ID to a file
func (tn *TendermintNode) SaveNodeIDToFile(filename string) error {
	nodeID, err := tn.GetNodeID()
	if err != nil {
		return err
	}

	return os.WriteFile(filename, []byte(nodeID), 0644)
}

// GetMempool returns the node's mempool
func (tn *TendermintNode) GetMempool() mempool.Mempool {
	if tn.node == nil {
		return nil
	}
	return tn.node.Mempool()
}

// PeerInfo represents information about a connected peer
type PeerInfo struct {
	ID         string
	RemoteAddr string
	IsOutbound bool
}

// GetPeers returns information about connected peers
func (tn *TendermintNode) GetPeers() []PeerInfo {
	if tn.node == nil {
		return nil
	}

	sw := tn.node.Switch()
	if sw == nil {
		return nil
	}

	peers := sw.Peers().List()
	var peerInfos []PeerInfo
	for _, peer := range peers {
		peerInfos = append(peerInfos, PeerInfo{
			ID:         string(peer.ID()),
			RemoteAddr: peer.RemoteAddr().String(),
			IsOutbound: peer.IsOutbound(),
		})
	}

	return peerInfos
}

// initializeTendermintConfig initializes the Tendermint configuration directory and files
func initializeTendermintConfig(tmConfig *TendermintConfig) (*config.Config, error) {
	// Create home directory
	if err := os.MkdirAll(tmConfig.HomeDir, 0755); err != nil {
		return nil, fmt.Errorf("failed to create home directory: %w", err)
	}

	// Create subdirectories
	dirs := []string{"config", "data"}
	for _, dir := range dirs {
		if err := os.MkdirAll(filepath.Join(tmConfig.HomeDir, dir), 0755); err != nil {
			return nil, fmt.Errorf("failed to create %s directory: %w", dir, err)
		}
	}

	// Initialize Tendermint config
	cfg := config.DefaultConfig()
	cfg.SetRoot(tmConfig.HomeDir)

	// Set P2P configuration
	cfg.P2P.ListenAddress = tmConfig.P2PListenAddr
	// AddrBook path is relative to root, so just use config/addrbook.json
	cfg.P2P.AddrBook = "config/addrbook.json"

	// Enable peer exchange for peer discovery
	cfg.P2P.PexReactor = true
	cfg.P2P.AllowDuplicateIP = true // Allow multiple nodes from same IP for testing

	// Set persistent peers (stay connected) instead of seeds (connect once)
	// For small networks, persistent peers work better than seeds
	if len(tmConfig.Seeds) > 0 {
		cfg.P2P.PersistentPeers = ""
		for i, seed := range tmConfig.Seeds {
			if i > 0 {
				cfg.P2P.PersistentPeers += ","
			}
			cfg.P2P.PersistentPeers += seed
		}
	}

	// Set RPC configuration
	cfg.RPC.ListenAddress = tmConfig.RPCListenAddr

	// Set consensus configuration
	cfg.Consensus.CreateEmptyBlocks = tmConfig.CreateEmptyBlocks
	cfg.Consensus.CreateEmptyBlocksInterval = 5 * time.Second // Create block every 5 seconds
	cfg.Consensus.TimeoutPropose = 3 * time.Second
	cfg.Consensus.TimeoutPrevote = 1 * time.Second
	cfg.Consensus.TimeoutPrecommit = 1 * time.Second
	cfg.Consensus.TimeoutCommit = 5 * time.Second // Wait 5 seconds before next block

	// Set mempool configuration
	cfg.Mempool.Size = 5000
	cfg.Mempool.CacheSize = 10000
	cfg.Mempool.MaxTxBytes = 1024 * 1024 // 1MB
	cfg.Mempool.Broadcast = true          // Enable mempool transaction broadcasting to peers

	// Set logging
	cfg.LogLevel = tmConfig.LogLevel

	// Use the embedded hardcoded genesis (same for all nodes)
	// This ensures all nodes are on the same blockchain
	genesisPath := filepath.Join(tmConfig.HomeDir, "config", "genesis.json")
	if err := os.WriteFile(genesisPath, []byte(GetEmbeddedTestnetGenesis()), 0644); err != nil {
		return nil, fmt.Errorf("failed to write genesis file: %w", err)
	}

	// Write config file
	configPath := filepath.Join(tmConfig.HomeDir, "config", "config.toml")
	config.WriteConfigFile(configPath, cfg)

	return cfg, nil
}

// SetupTendermintQuietMode applies additional quiet mode settings to reduce Tendermint noise
func SetupTendermintQuietMode() {
	// Redirect standard Go log output to discard to catch any remaining Tendermint logs
	log.SetOutput(io.Discard)
}

// RestoreTendermintLogging restores normal logging after quiet mode
func RestoreTendermintLogging() {
	log.SetOutput(os.Stderr)
}

// FarmerStats tracks farming participation for dynamic validator set
type FarmerStats struct {
	Address        Address
	ProofCount     int64 // Total valid proofs submitted
	LastProofHeight int64 // Last block height where proof was submitted
	IsValidator    bool  // Currently in validator set
	ValidatorPower int64 // Voting power (10 for now, will add staking later)
}

// ShadowyApp is a minimal ABCI application for Shadowy blockchain
type ShadowyApp struct {
	// Block height tracking
	height int64
	// Simple state hash for commitment
	stateHash [32]byte
	// UTXO store for persistent state
	utxoStore *UTXOStore
	// Node wallet address for coinbase rewards
	nodeAddress Address
	// Node wallet private key for mining
	nodePrivateKey []byte
	// Farmer tracking for dynamic validator set
	farmers map[string]*FarmerStats // key: address string
	db      db.DB                   // Database for persistent state
	// Flag indicating if this node is a validator
	isValidator bool
}

// NewShadowyApp creates a new Shadowy ABCI application
func NewShadowyApp(nodeAddress Address) *ShadowyApp {
	// Create persistent database for UTXO storage using BadgerDB
	utxoStore, err := NewUTXOStore("data/utxo")
	if err != nil {
		log.Fatalf("Failed to create UTXO store: %v", err)
	}

	// Migrate existing coinbase transactions from UTXOs
	if err := utxoStore.MigrateCoinbaseTransactions(); err != nil {
		log.Printf("Warning: Failed to migrate coinbase transactions: %v", err)
	}

	app := &ShadowyApp{
		utxoStore:   utxoStore,
		nodeAddress: nodeAddress,
		farmers:     make(map[string]*FarmerStats),
		db:          database,
	}

	// Load farmer stats from database
	app.loadFarmerStats()

	return app
}

// Info returns application info
func (app *ShadowyApp) Info(req abcitypes.RequestInfo) abcitypes.ResponseInfo {
	return abcitypes.ResponseInfo{
		Data:    "Shadowy Post-Quantum UTXO Blockchain",
		Version: "1.0.0",
	}
}

// InitChain initializes the blockchain
func (app *ShadowyApp) InitChain(req abcitypes.RequestInitChain) abcitypes.ResponseInitChain {
	// Parse genesis state
	var genesisState map[string]interface{}
	if err := json.Unmarshal(req.AppStateBytes, &genesisState); err != nil {
		// For now, just log the error but don't fail startup
		fmt.Printf("Warning: failed to parse genesis state: %v\n", err)
	}

	return abcitypes.ResponseInitChain{}
}

// CheckTx validates transactions for mempool
func (app *ShadowyApp) CheckTx(req abcitypes.RequestCheckTx) abcitypes.ResponseCheckTx {
	fmt.Printf("🔍 CheckTx START\n")

	// Try to parse as JSON transaction first
	var tx Transaction
	if err := json.Unmarshal(req.Tx, &tx); err == nil {
		// Standard Shadowy transaction - validate signatures/structure only
		// IMPORTANT: Do NOT validate against UTXO set here to avoid deadlocks
		// The UTXO set is locked during block execution, and CheckTx can be called concurrently
		if err := ValidateTransaction(&tx); err != nil {
			fmt.Printf("🔍 CheckTx: Validation failed: %v\n", err)
			return abcitypes.ResponseCheckTx{
				Code: 1,
				Log:  fmt.Sprintf("Invalid transaction: %v", err),
			}
		}

		// REMOVED: UTXO validation during CheckTx to prevent deadlock
		// UTXO validation will happen in DeliverTx instead
		fmt.Printf("🔍 CheckTx: OK\n")
		return abcitypes.ResponseCheckTx{Code: 0} // Accept
	}

	// Check if this is a proof-of-space transaction
	if isProofOfSpaceTransaction(req.Tx) {
		if validateProofTransaction(req.Tx) {
			return abcitypes.ResponseCheckTx{Code: 0} // Accept
		} else {
			return abcitypes.ResponseCheckTx{
				Code: 1,
				Log:  "Invalid proof-of-space transaction",
			}
		}
	}

	// Unknown transaction format
	return abcitypes.ResponseCheckTx{
		Code: 1,
		Log:  "Unknown transaction format",
	}
}

// PrepareProposal prepares a proposal for the next block
func (app *ShadowyApp) PrepareProposal(req abcitypes.RequestPrepareProposal) abcitypes.ResponsePrepareProposal {
	return abcitypes.ResponsePrepareProposal{
		Txs: req.Txs, // For now, just include all transactions as-is
	}
}

// ProcessProposal validates a proposed block
func (app *ShadowyApp) ProcessProposal(req abcitypes.RequestProcessProposal) abcitypes.ResponseProcessProposal {
	return abcitypes.ResponseProcessProposal{
		Status: abcitypes.ResponseProcessProposal_ACCEPT,
	}
}

// BeginBlock handles begin block - this is where block rewards and mining happen
func (app *ShadowyApp) BeginBlock(req abcitypes.RequestBeginBlock) abcitypes.ResponseBeginBlock {
	app.height = req.Header.Height

	// Generate challenge hash for proof of space mining
	challengeHash := generateChallengeHashFromProto(req.Header)

	if farmingDebugMode {
		fmt.Printf("🎯 Block %d challenge hash: %x\n", app.height, challengeHash)
	}

	// IMPORTANT: For determinism, all nodes must execute the same coinbase
	// We award the block proposer (from req.Header.ProposerAddress) to ensure
	// all nodes compute the same state. In the future, we should include
	// proof-of-space in block transactions for proper consensus.

	// Convert proposer address to our Address type
	// ProposerAddress is a CometBFT validator address (first 20 bytes of validator pubkey hash)
	proposerAddr := req.Header.ProposerAddress
	if len(proposerAddr) == 0 {
		if farmingDebugMode {
			fmt.Printf("⚠️ No proposer address in block header\n")
		}
		return abcitypes.ResponseBeginBlock{}
	}

	// DETERMINISTIC COINBASE AWARD - CRITICAL FOR CONSENSUS
	// All nodes MUST award the same address or consensus will fail
	//
	// Look up validator's registered wallet address
	// If not registered, use derived address (creates orphaned coins)

	var minerAddress Address

	// Try to get registered wallet address for this validator
	if registeredAddr, err := app.utxoStore.GetValidatorWallet(proposerAddr); err == nil && registeredAddr != nil {
		// Validator has registered their wallet address
		minerAddress = *registeredAddr
		if farmingDebugMode {
			fmt.Printf("💰 Block proposer: %x\n", proposerAddr)
			fmt.Printf("   ✅ Registered wallet: %s\n", minerAddress.String()[:40]+"...")
		}
	} else {
		// Validator not registered - use derived address (orphaned coins)
		proposerHash := blake2b.Sum256(proposerAddr)
		copy(minerAddress[:], proposerHash[:])
		if farmingDebugMode {
			fmt.Printf("💰 Block proposer: %x\n", proposerAddr)
			fmt.Printf("   ⚠️  UNREGISTERED - orphaned address: %s\n", minerAddress.String()[:40]+"...")
		}
	}

	// Create coinbase transaction for mining reward
	// Use block timestamp for determinism - all nodes must create identical transaction
	blockReward := uint64(50 * 1e8) // 50 SHADOW tokens (8 decimals)
	blockTimestamp := req.Header.Time.Unix()
	coinbaseTx := CreateCoinbaseTransaction(minerAddress, uint64(app.height), blockReward, blockTimestamp)

	// Execute the coinbase transaction to award the block reward
	if err := executeTransaction(coinbaseTx, app.height, app.utxoStore); err != nil {
		if farmingDebugMode {
			fmt.Printf("❌ Failed to execute coinbase transaction: %v\n", err)
		}
	} else {
		if farmingDebugMode {
			fmt.Printf("✅ Block reward of %d SHADOW awarded\n", blockReward)
		}
		// Track this farmer's proof for validator set management
		app.recordFarmingProof(minerAddress, app.height)
	}

	// Keep proof generation for future use, but don't use it for rewards yet
	if false { // Disabled for now - will re-enable when we can include proofs in blocks
		// No mining proofs - this code path is disabled
		if farmingDebugMode {
			fmt.Printf("⏳ Block %d created - awarding coinbase for testing\n", app.height)
		}

		// Create coinbase transaction for testing (using node wallet address)
		blockReward := uint64(50 * 1e8) // 50 SHADOW tokens (8 decimals)

		// Use the node's wallet address for coinbase rewards
		minerAddress := app.nodeAddress

		blockTimestamp := req.Header.Time.Unix()
		coinbaseTx := CreateCoinbaseTransaction(minerAddress, uint64(app.height), blockReward, blockTimestamp)

		// Execute the coinbase transaction
		if err := executeTransaction(coinbaseTx, app.height, app.utxoStore); err != nil {
			if farmingDebugMode {
				fmt.Printf("❌ Failed to execute test coinbase transaction: %v\n", err)
			}
		} else {
			if farmingDebugMode {
				fmt.Printf("💰 Test block reward of %d awarded to address: %x\n", blockReward, minerAddress[:8])
			}
			// Track this farming activity
			app.recordFarmingProof(minerAddress, app.height)
		}
	}

	return abcitypes.ResponseBeginBlock{}
}

// DeliverTx executes transactions
func (app *ShadowyApp) DeliverTx(req abcitypes.RequestDeliverTx) abcitypes.ResponseDeliverTx {
	fmt.Printf("🔍 DeliverTx START\n")

	// Try to parse as JSON transaction first
	var tx Transaction
	if err := json.Unmarshal(req.Tx, &tx); err == nil {
		fmt.Printf("🔍 DeliverTx: Parsed transaction\n")

		// Handle validator registration separately
		if tx.TxType == TxTypeRegisterValidator {
			fmt.Printf("🔍 DeliverTx: Processing validator registration\n")

			// Data should contain: proposer_address (20 bytes) + wallet_address (32 bytes)
			if len(tx.Data) != 52 {
				fmt.Printf("🔍 DeliverTx: Invalid registration data length: %d\n", len(tx.Data))
				return abcitypes.ResponseDeliverTx{
					Code: 1,
					Log:  fmt.Sprintf("Invalid validator registration data: expected 52 bytes, got %d", len(tx.Data)),
				}
			}

			proposerAddr := tx.Data[:20]
			var walletAddr Address
			copy(walletAddr[:], tx.Data[20:52])

			if err := app.utxoStore.RegisterValidator(proposerAddr, walletAddr); err != nil {
				fmt.Printf("🔍 DeliverTx: Registration failed: %v\n", err)
				return abcitypes.ResponseDeliverTx{
					Code: 1,
					Log:  fmt.Sprintf("Validator registration failed: %v", err),
				}
			}

			fmt.Printf("🔍 DeliverTx: Validator registered successfully\n")
			return abcitypes.ResponseDeliverTx{Code: 0}
		}

		// Standard Shadowy transaction - execute it
		if err := ValidateTransaction(&tx); err != nil {
			fmt.Printf("🔍 DeliverTx: Validation failed: %v\n", err)
			return abcitypes.ResponseDeliverTx{
				Code: 1,
				Log:  fmt.Sprintf("Transaction validation failed: %v", err),
			}
		}
		fmt.Printf("🔍 DeliverTx: Validation passed\n")

		// Execute the transaction (update UTXO set, balances, etc.)
		fmt.Printf("🔍 DeliverTx: About to execute transaction\n")
		if err := executeTransaction(&tx, app.height, app.utxoStore); err != nil {
			fmt.Printf("🔍 DeliverTx: Execution failed: %v\n", err)
			return abcitypes.ResponseDeliverTx{
				Code: 1,
				Log:  fmt.Sprintf("Transaction execution failed: %v", err),
			}
		}
		fmt.Printf("🔍 DeliverTx: Execution completed\n")

		if farmingDebugMode {
			fmt.Printf("🔄 Executed transaction: %s\n", GetTransactionSummary(&tx))
		}

		return abcitypes.ResponseDeliverTx{Code: 0}
	}

	// Handle proof-of-space transactions
	if isProofOfSpaceTransaction(req.Tx) {
		if validateProofTransaction(req.Tx) {
			// Process mining proof submission
			if farmingDebugMode {
				fmt.Printf("⛏️ Processed mining proof submission\n")
			}
			return abcitypes.ResponseDeliverTx{Code: 0}
		} else {
			return abcitypes.ResponseDeliverTx{
				Code: 1,
				Log:  "Invalid proof-of-space transaction",
			}
		}
	}

	return abcitypes.ResponseDeliverTx{
		Code: 1,
		Log:  "Unknown transaction format",
	}
}

// EndBlock handles end block
func (app *ShadowyApp) EndBlock(req abcitypes.RequestEndBlock) abcitypes.ResponseEndBlock {
	// Check for validator set updates (promotions/demotions)
	// TODO: TEMPORARILY DISABLED - validator updates causing consensus halt
	// validatorUpdates := app.updateValidatorSet()

	if farmingDebugMode {
		// Just log what WOULD happen for debugging
		updates := app.updateValidatorSet()
		if len(updates) > 0 {
			log.Printf("🔄 Would apply %d validator updates (disabled)", len(updates))
		}
	}

	return abcitypes.ResponseEndBlock{
		ValidatorUpdates: nil, // Disabled for now
	}
}

// Commit commits state changes
func (app *ShadowyApp) Commit() abcitypes.ResponseCommit {
	// Update state hash based on current block height and any state changes
	hasher := sha256.New()
	hasher.Write([]byte(fmt.Sprintf("block_%d", app.height)))
	hasher.Write(app.stateHash[:])
	newStateHash := sha256.Sum256(hasher.Sum(nil))
	app.stateHash = newStateHash

	if farmingDebugMode {
		fmt.Printf("💾 Committed state for block %d: %x\n", app.height, app.stateHash[:8])
	}

	return abcitypes.ResponseCommit{
		Data: app.stateHash[:],
	}
}

// Query handles state queries
func (app *ShadowyApp) Query(req abcitypes.RequestQuery) abcitypes.ResponseQuery {
	// TODO: Implement state queries
	return abcitypes.ResponseQuery{Code: 0}
}

// Snapshot methods (minimal implementation)
func (app *ShadowyApp) ListSnapshots(req abcitypes.RequestListSnapshots) abcitypes.ResponseListSnapshots {
	return abcitypes.ResponseListSnapshots{}
}

func (app *ShadowyApp) OfferSnapshot(req abcitypes.RequestOfferSnapshot) abcitypes.ResponseOfferSnapshot {
	return abcitypes.ResponseOfferSnapshot{
		Result: abcitypes.ResponseOfferSnapshot_REJECT,
	}
}

func (app *ShadowyApp) LoadSnapshotChunk(req abcitypes.RequestLoadSnapshotChunk) abcitypes.ResponseLoadSnapshotChunk {
	return abcitypes.ResponseLoadSnapshotChunk{}
}

func (app *ShadowyApp) ApplySnapshotChunk(req abcitypes.RequestApplySnapshotChunk) abcitypes.ResponseApplySnapshotChunk {
	return abcitypes.ResponseApplySnapshotChunk{
		Result: abcitypes.ResponseApplySnapshotChunk_UNKNOWN,
	}
}

// generateChallengeHashFromProto creates a challenge hash from ABCI proto header
func generateChallengeHashFromProto(header tmproto.Header) [32]byte {
	// Create challenge from block height, time, and last block hash
	challenge := fmt.Sprintf("%d:%s:%x", header.Height, header.Time, header.LastBlockId.Hash)
	return sha256.Sum256([]byte(challenge))
}

// copyNodeKey copies the persistent node key to the blockchain config directory
func copyNodeKey(srcFile, dstFile string) error {
	// Read the source file
	data, err := os.ReadFile(srcFile)
	if err != nil {
		return fmt.Errorf("failed to read source node key: %w", err)
	}

	// Ensure the destination directory exists
	dstDir := filepath.Dir(dstFile)
	if err := os.MkdirAll(dstDir, 0755); err != nil {
		return fmt.Errorf("failed to create destination directory: %w", err)
	}

	// Write to the destination file
	if err := os.WriteFile(dstFile, data, 0644); err != nil {
		return fmt.Errorf("failed to write destination node key: %w", err)
	}

	return nil
}

// Mining/Proof-of-Space transaction handling functions

// isProofOfSpaceTransaction checks if a transaction contains a mining proof
func isProofOfSpaceTransaction(tx []byte) bool {
	// Simple check - look for proof-of-space transaction marker
	// In a real implementation, this would parse the transaction structure
	return len(tx) > 10 && string(tx[:10]) == "PROOF_OF_S"
}

// validateProofTransaction validates a proof-of-space transaction
func validateProofTransaction(tx []byte) bool {
	// TODO: Parse the transaction and extract the proof
	// TODO: Validate the proof using ValidateProofOfSpace
	// For now, just return true for demonstration
	return true
}

// findBestProofInTransactions finds the mining proof with the lowest distance
func findBestProofInTransactions(txs [][]byte) *ProofOfSpace {
	var bestProof *ProofOfSpace
	bestDistance := uint64(^uint64(0)) // Max uint64

	for _, tx := range txs {
		if isProofOfSpaceTransaction(tx) {
			// TODO: Parse the transaction to extract the proof
			// proof := parseProofFromTransaction(tx)
			// For now, create a dummy proof for demonstration
			if len(tx) > 0 {
				dummyProof := &ProofOfSpace{
					Distance:       uint64(len(tx) % 1000), // Dummy distance based on tx length
					MinerPublicKey: []byte("dummy_miner_key"),
				}

				if dummyProof.Distance < bestDistance {
					bestDistance = dummyProof.Distance
					bestProof = dummyProof
				}
			}
		}
	}

	return bestProof
}

// executeTransaction processes a transaction and updates state
func executeTransaction(tx *Transaction, blockHeight int64, utxoStore *UTXOStore) error {
	fmt.Printf("🔍 executeTransaction: START\n")

	// Validate transaction against UTXO set
	if utxoStore != nil {
		fmt.Printf("🔍 executeTransaction: Validating against UTXO set\n")
		if err := utxoStore.ValidateTransaction(tx); err != nil {
			fmt.Printf("🔍 executeTransaction: UTXO validation failed: %v\n", err)
			return fmt.Errorf("UTXO validation failed: %w", err)
		}
		fmt.Printf("🔍 executeTransaction: UTXO validation passed\n")
	}

	// Validate transaction signatures and structure
	fmt.Printf("🔍 executeTransaction: Validating signatures\n")
	if err := ValidateTransaction(tx); err != nil {
		fmt.Printf("🔍 executeTransaction: Signature validation failed: %v\n", err)
		return fmt.Errorf("transaction validation failed: %w", err)
	}
	fmt.Printf("🔍 executeTransaction: Signature validation passed\n")

	// Update UTXO set if we have persistent storage
	if utxoStore != nil {
		// Spend input UTXOs (except for coinbase transactions)
		if tx.TxType != TxTypeCoinbase {
			fmt.Printf("🔍 executeTransaction: Spending %d inputs\n", len(tx.Inputs))
			for i, input := range tx.Inputs {
				fmt.Printf("🔍 executeTransaction: Spending input %d/%d\n", i+1, len(tx.Inputs))
				if err := utxoStore.SpendUTXO(input.PrevTxID, input.OutputIndex); err != nil {
					fmt.Printf("🔍 executeTransaction: Failed to spend UTXO: %v\n", err)
					return fmt.Errorf("failed to spend UTXO %s:%d: %w", input.PrevTxID, input.OutputIndex, err)
				}
			}
			fmt.Printf("🔍 executeTransaction: All inputs spent\n")
		}

		// Create new UTXOs from outputs
		fmt.Printf("🔍 executeTransaction: Getting transaction ID\n")
		txID, err := tx.ID()
		if err != nil {
			fmt.Printf("🔍 executeTransaction: Failed to get TX ID: %v\n", err)
			return fmt.Errorf("failed to get transaction ID: %w", err)
		}
		fmt.Printf("🔍 executeTransaction: TX ID = %s\n", txID)

		fmt.Printf("🔍 executeTransaction: Creating %d outputs\n", len(tx.Outputs))
		for i, output := range tx.Outputs {
			fmt.Printf("🔍 executeTransaction: Creating output %d/%d\n", i+1, len(tx.Outputs))
			utxo := &UTXO{
				TxID:        txID,
				OutputIndex: uint32(i),
				Output:      output,
				BlockHeight: uint64(blockHeight),
				IsSpent:     false,
			}

			if err := utxoStore.AddUTXO(utxo); err != nil {
				fmt.Printf("🔍 executeTransaction: Failed to add UTXO: %v\n", err)
				return fmt.Errorf("failed to add UTXO %s:%d: %w", txID, i, err)
			}
		}
		fmt.Printf("🔍 executeTransaction: All outputs created\n")

		// Store the transaction
		fmt.Printf("🔍 executeTransaction: Storing transaction\n")
		if err := utxoStore.StoreTransaction(tx, blockHeight); err != nil {
			fmt.Printf("🔍 executeTransaction: Failed to store transaction: %v\n", err)
			return fmt.Errorf("failed to store transaction: %w", err)
		}
		fmt.Printf("🔍 executeTransaction: Transaction stored\n")
	}

	fmt.Printf("🔍 executeTransaction: COMPLETE\n")
	return nil
}

// Farmer tracking and validator management methods

const (
	FarmerPrefix            = "farmer:" // farmer:{address} -> FarmerStats
	MinProofsForPromotion   = 5         // Number of valid proofs needed to become validator
	MaxBlocksWithoutProof   = 100       // Blocks without proof before demotion
	DefaultValidatorPower   = 10        // Default voting power for farmers
)

// loadFarmerStats loads farmer statistics from persistent storage
func (app *ShadowyApp) loadFarmerStats() {
	if app.db == nil {
		return
	}

	// Iterate through farmer records
	iterator, err := app.db.Iterator([]byte(FarmerPrefix), nil)
	if err != nil {
		log.Printf("Warning: Failed to load farmer stats: %v", err)
		return
	}
	defer iterator.Close()

	loaded := 0
	for ; iterator.Valid(); iterator.Next() {
		var stats FarmerStats
		if err := json.Unmarshal(iterator.Value(), &stats); err != nil {
			continue
		}
		app.farmers[stats.Address.String()] = &stats
		loaded++
	}

	if loaded > 0 {
		log.Printf("Loaded %d farmer records from database", loaded)
	}
}

// saveFarmerStats persists farmer statistics to database
func (app *ShadowyApp) saveFarmerStats(stats *FarmerStats) error {
	if app.db == nil {
		return nil
	}

	key := fmt.Sprintf("%s%s", FarmerPrefix, stats.Address.String())
	data, err := json.Marshal(stats)
	if err != nil {
		return err
	}

	return app.db.Set([]byte(key), data)
}

// recordFarmingProof records a valid farming proof submission
func (app *ShadowyApp) recordFarmingProof(minerAddress Address, height int64) {
	addrStr := minerAddress.String()
	
	stats, exists := app.farmers[addrStr]
	if !exists {
		stats = &FarmerStats{
			Address:        minerAddress,
			ProofCount:     0,
			LastProofHeight: height,
			IsValidator:    false,
			ValidatorPower: 0,
		}
		app.farmers[addrStr] = stats
	}

	stats.ProofCount++
	stats.LastProofHeight = height

	// Save to database
	if err := app.saveFarmerStats(stats); err != nil {
		log.Printf("Warning: Failed to save farmer stats for %s: %v", addrStr, err)
	}

	if farmingDebugMode {
		fmt.Printf("📊 Farmer %s now has %d proofs (last: block %d)\n", 
			addrStr[:16], stats.ProofCount, height)
	}
}

// updateValidatorSet checks for promotions/demotions and returns validator updates
func (app *ShadowyApp) updateValidatorSet() []abcitypes.ValidatorUpdate {
	var updates []abcitypes.ValidatorUpdate

	for _, stats := range app.farmers {
		// Check for promotion: enough proofs and not yet a validator
		if !stats.IsValidator && stats.ProofCount >= MinProofsForPromotion {
			// Promote to validator
			stats.IsValidator = true
			stats.ValidatorPower = DefaultValidatorPower

			// Create validator update using helper (power > 0 = add)
			// Use address bytes as public key identifier (Ed25519 expects 32 bytes)
			update := abcitypes.Ed25519ValidatorUpdate(stats.Address[:], stats.ValidatorPower)
			updates = append(updates, update)

			log.Printf("🎖️  PROMOTED farmer %s to validator (proofs: %d)",
				stats.Address.String()[:16], stats.ProofCount)

			app.saveFarmerStats(stats)
		}

		// Check for demotion: validator with no recent proofs
		if stats.IsValidator && (app.height - stats.LastProofHeight) > MaxBlocksWithoutProof {
			// Demote from validator
			stats.IsValidator = false
			oldPower := stats.ValidatorPower
			stats.ValidatorPower = 0

			// Create validator update (power = 0 = remove)
			update := abcitypes.Ed25519ValidatorUpdate(stats.Address[:], 0)
			updates = append(updates, update)

			log.Printf("⬇️  DEMOTED validator %s (no proof for %d blocks, had power: %d)", 
				stats.Address.String()[:16], app.height - stats.LastProofHeight, oldPower)

			app.saveFarmerStats(stats)
		}
	}

	return updates
}
